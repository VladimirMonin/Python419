// Lesson 12 - Знакомство с JS

// Вывод в консоль - часто испольуется для логирования
console.log("Простой лог");
console.warn("Предупреждение");
console.error("Ошибка");

// Вывод в браузер
// alert("Оповещение")

// Переменные

// Отличия var и let:
// 1. Область видимости (Scope):
//    - var имеет функциональную область видимости (function scope). Переменная, объявленная через var, видна во всей функции, в которой она объявлена.
//    - let имеет блочную область видимости (block scope). Переменная, объявленная через let, видна только внутри блока кода (например, внутри фигурных скобок {}), где она объявлена.
// 2. Поднятие (Hoisting):
//    - var переменные поднимаются (hoisted) и инициализируются значением undefined в начале своей области видимости.
//    - let переменные тоже поднимаются, но не инициализируются. До момента объявления к ним нельзя обращаться — это приводит к ошибке ReferenceError (так называемая "временная мёртвая зона" — Temporal Dead Zone).
// 3. Повторное объявление:
//    - var позволяет повторно объявлять одну и ту же переменную в одной области видимости без ошибок.
//    - let не позволяет повторно объявлять переменную в одной области видимости — это вызовет ошибку.
// 4. Глобальные переменные:
//    - var, объявленный в глобальной области, становится свойством глобального объекта (window в браузере). Это похоже на встроенную область видимости (built-in namespace) в Python.
//    - let, объявленный в глобальной области, не становится свойством глобального объекта.
// 5. Использование:
//    - var — устаревший способ объявления переменных, его использование не рекомендуется в современном коде.
//    - let — современный способ объявления изменяемых переменных с более предсказуемым поведением.
let first_name = "Переменная";
const last_name = "Константа";

first_name = "Новые данные";
// last_name = "Новые данные" // Uncaught TypeError: invalid assignment to const 'last_name'

// prompt - получить от пользователя данные
let user_name = prompt("Введите ваше имя");
console.log(user_name);

// Сложение строк
console.log("Привет" + " " + user_name + "!");

// Шаблонная строка. Используется "тик" - оратная кавычка, буква ё на английской раскладке и символ доллара

console.log(`Привет ${user_name}!!!!!`);

// Типы данных

// Примитивные типы данных
// number - число
let some_number = 1234567890;

// string - строка
let some_string = "Строка";

// boolean - логический тип данных. Может принимать только два значения: true или false
let some_true = true;
let some_false = false;

// null - пустота. Ничего. Пустой объект
// null - это явное присвоение значения "пустота" или "отсутствие значения".
// Это специальное значение, которое программист может присвоить переменной,
// чтобы показать, что там нет никакого объекта или значения.
// Например, когда нужно явно указать, что переменная сейчас "пустая".
let some_null = null;

// undefined - неопределенность. Переменная объявлена, но не имеет значения
// undefined - это значение по умолчанию для переменной, которая была объявлена,
// но ей не присвоено никакого значения.
// Это означает, что переменная существует, но её значение ещё не определено.
// undefined обычно сигнализирует о том, что переменная ещё не была инициализирована
// или что функция не возвращает значение.
let some_undefined;

// Правильно будет обяъвитьпеременную либо let banana, либо let banana = null
// let banana = undefined - это не правильно!!!!!!

let isAdult;
isAdult = confirm("Вам есть 18 лет?");
console.log(isAdult);

// Как проверить тип данных?
// typeof - оператор, который возвращает тип данных переменной

console.log(typeof isAdult);
console.log(typeof some_null); // Из-за исторической ошибки в JavaScript, typeof null возвращает "object".
console.log(typeof some_undefined);

// Правила нейминга переменных

// 1. Без пробелов
// 2. Без цифр в начале3. Без спецсимволов (кроме _ и $)
// 3. Нельзя использовать зарезервированные слова
// 4. Переменные чувствительны к регистру
// 5. Используйте осмысленные имена
// 6. Используйте lowerCamelCase для переменных и функций

// Математические операторы

// + - * / % **
// % - остаток от деления

console.log(2 + 2); // 4 - сложение 2х чисел
console.log("2" + 2); // 22 - сложение строки и числа
console.log("2" + "2"); // 22 - сложение строк

// Приведение типов. Преобразем 2 в число
let num_string = "2";

console.log(parseInt(num_string) + 2); // 4 - parseInt() парсит строку до первого нечислового символа, возвращает целое число. Отбрасывает дробную часть. Всегда указывайте radix (основание системы счисления, обычно 10) для предсказуемого поведения.
console.log(Number(num_string) + 2); // 4 - Number() строго преобразует всю строку в число. Если строка содержит любые нечисловые символы (кроме пробелов, знаков +/- или десятичной точки), вернет NaN. Пустая строка и null преобразуются в 0.
console.log(+num_string + 2); // 4 - Унарный плюс (+) - краткая форма Number(), работает аналогично. Самый быстрый способ преобразования.

// NaN (Not-a-Number) - "Не число"
// Это специальное числовое значение, которое указывает на то, что результат математической операции не является корректным или представимым числом.
// Например, при попытке преобразовать нечисловую строку в число или при делении нуля на ноль.
console.log(parseInt("hello") + 2); // NaN - "hello" не может быть преобразовано в число
console.log(Number("world") + 2); // NaN - "world" не может быть преобразовано в число
console.log(+"abc" + 2); // NaN - "abc" не может быть преобразовано в число
console.log(0 / 0); // NaN - деление нуля на ноль
console.log(NaN + 1); // NaN - любая операция с NaN возвращает NaN
console.log(NaN == NaN); // false - NaN не равен даже самому себе!
console.log(isNaN(NaN)); // true - используйте isNaN() для проверки на NaN
console.log(isNaN(123)); // false
console.log(isNaN("123")); // false - isNaN() пытается преобразовать в число, затем проверяет
console.log(Number.isNaN(NaN)); // true - Number.isNaN() более строгая проверка, не преобразует
console.log(Number.isNaN("123")); // false
console.log(parseInt("20 серий аниме")); // 20 - parseInt() преобразует строку до первого нечислового символа

// Приведение к boolean

console.log(`Boolean(0) = ${Boolean(0)}`); // false
console.log(`Boolean(1) = ${Boolean(1)}`); // true
console.log(`Boolean("") = ${Boolean("")}`); // false
console.log(`Boolean(" ") = ${Boolean(" ")}`); // true
console.log(`Boolean("Hello") = ${Boolean("Hello")}`); // true
console.log(`Boolean(null) = ${Boolean(null)}`); // false
console.log(`Boolean(undefined) = ${Boolean(undefined)}`); // false
console.log(`Boolean(NaN) = ${Boolean(NaN)}`); // false
console.log(`Boolean({}) = ${Boolean({})}`); // true
console.log(`Boolean([]) = ${Boolean([])}`); // true

// Операторы сравнений
// При нестрогих проверках типы данных приводятся к одному типу. Это может быть опасно
console.log(`1 == "1" = ${1 == "1"}`); // true - нестрогое равенство (с приведением типов)
console.log(`1 === "1" = ${1 === "1"}`); // false - строгое равенство (без приведения типов)
console.log(`1 != "1" = ${1 != "1"}`); // false - нестрогое неравенство (с приведением типов)
console.log(`1 !== "1" = ${1 !== "1"}`); // true - строгое неравенство (без приведения типов)

// - Строка преобразуется в число.
// - Пример: `5 == "5"` -> `"5"` преобразуется в `5`, затем `5 == 5` -> `true`.
// - Пример: `10 == "10px"` -> `"10px"` преобразуется в `NaN`, затем `10 == NaN` -> `false` (поскольку `NaN` не равен ничему, даже самому себе).

// - Булево значение преобразуется в число: `true` становится `1`, `false` становится `0`.
// - Пример: `1 == true` -> `true` преобразуется в `1`, затем `1 == 1` -> `true`.
// - Пример: `0 == false` -> `false` преобразуется в `0`, затем `0 == 0` -> `true`.

// - Это особый случай: `null` и `undefined` считаются равными друг другу при нестрогом сравнении, но не равны никаким другим значениям.

// - Пример: `null == undefined` -> `true`.
// - Пример: `null == 0` -> `false`.
// - Пример: `undefined == 0` -> `false`.
// - Пример: `null == false` -> `false`.
// - Пример: `undefined == false` -> `false`.

// - `NaN` не равен ничему, даже самому себе.
// - Пример: `NaN == NaN` -> `false`.
// - Пример: `NaN == 0` -> `false`.
// - Для проверки на `NaN` всегда используйте `isNaN()` или `Number.isNaN()`.

let isMarried = true;

if (isMarried) {
  console.log("Женат");
} else {
  console.log("Не женат");
}

// Более сложный вариант ветвления с else if
let age = 19;

// if (age > 18) {
//   console.log("Возраст больше 18");
// }
// if (age > 18) {
//   console.log("Возраст больше 18. IF отработают все");
// } else {
//   console.log("Возраст меньше 18");
// }

if (age > 18) {
  console.log("Возраст больше 18");
} else if (age > 18) {
  console.log("Возраст больше 18. IF отработают все");
} else {
  console.log("Возраст меньше 18");
}

// Логические операторы в порядке приоритета
// 1. () - группировка условий через скобки
// 2. ! - логическое отрицание (унарный оператор)
// 3. && - логическое И (бинарный оператор)
// 4. || - логическое ИЛИ (бинарный оператор)

let userInput

employeeAge = parseInt(prompt("Введите возраст"));
console.log(`Пользователь ввел возраст ${employeeAge} типа ${typeof employeeAge}`);

// Если возраст меньше 18 - не принимаем на работу
// Если возвраст больше 70 - не принимаем на работу
// Если в диапазоне 18-23 - Аниматор Пикачу
//  Если в диапазоне 24-30 - Курьер
// Старше - директор фирмы)))
if (isNaN(employeeAge)) {
  console.log("Возраст не число");
} else if (employeeAge < 18) {
  console.log(`Возраст ${employeeAge} слишком мал. Приходите позже`);
} else if (employeeAge > 70) {
  console.log(
    `Возраст ${employeeAge} слишком велик. Приходите вс следующей жизни`
  );
} else if (employeeAge >= 18 && employeeAge <= 23) {
  console.log(`Возраст ${employeeAge}. Вы - Аниматор Пикачу за доширак!`);
} else if (employeeAge >= 24 && employeeAge <= 30) {
  console.log(`Возраст ${employeeAge}. Вы - Курьер! За шаурму!`);
} else if (employeeAge > 30 && employeeAge <= 70) {
  console.log(`Возраст ${employeeAge}. Вы - Директор фирмы!`);
}


//TODO Отложить тернарный IF на следующий раз
//TODO Посмотреть отладчик в браузере и может в редакторе